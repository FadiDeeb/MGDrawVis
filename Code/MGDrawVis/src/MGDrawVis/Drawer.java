
package MGDrawVis;

import java.math.RoundingMode;
import java.text.DecimalFormat;

public class Drawer 
{
    public ObjectiveFunction objFunCost;  // objective function of the drawer
    public boolean running;  // whether the drawer is running or not 
    public int phaseNumber;  // which phase of experiment this drawer is running (0,1,2,3) 
    public int numEvaluatedSolutions; // numbr of solutions generated by the drawer 
    public long executionTime; // execution time 
    public String name; // name of the drawer (to add to the generated folder of experiment) 
    
    // this is used only for creating the generic drawer to generate random graphs for normalization
    public Drawer(int n, Graph graph)
    { 
        objFunCost = new ObjectiveFunction(graph);
        generateRandomGraphsForNormalization(graph);   // for normalization purpose 
        numEvaluatedSolutions = 0; 
        executionTime = 0; 
        running = false; 
        name = "no Name";
        phaseNumber = 0; 
    }
    
    // this is used to create all the other drawers. The drawer parameter must be the initial generic drawer 
    public Drawer (Graph graph, Drawer d)
    {
        objFunCost = new ObjectiveFunction(graph); 
        objFunCost.copyHistory(d.objFunCost);
        numEvaluatedSolutions = 0; 
        executionTime = 0; 
        name = "no Name";
        running = false; 
        phaseNumber = 0; 
    }
    
    /*********** the following methods must be implemented in each drawer algorithm *****/
    public void getParameters(DrawingStageActions draw, Graph graph) 
    {
        System.out.println("Implement within the drawer itself");
    }
    
    public void runAnimated (DrawingStageActions draw, Graph graph)
    {
        System.out.println("Implement within the drawer itself");
    }
    
    // run drawer with no limtation 
    public void run0 (DrawingStageActions draw, Graph graph)
    {
        System.out.println("Implement within the drawer itself");
    }
    
    // run drawer for fixed number of evaluated solutions 
    public void run1 (DrawingStageActions draw, Graph graph)
    {
        System.out.println("Fixed Evaluated Solutions");
    }
    
    // run drawer for fixed objective function value 
    public void run2 (DrawingStageActions draw, Graph graph)
    {
        System.out.println("Fixed Objective Function value");
    }
    
    // run drawer for fixd execution time 
    public void run3 (DrawingStageActions draw, Graph graph)
    {
        System.out.println("Fixed Execution Time");
    }
    
     /***************** generate random graphs for normalization purposes ************/
    private void generateRandomGraphsForNormalization(Graph graph)
    {
       Graph g = new Graph(); 
       g.copyGraph(graph);
       for(int i=0; i<100; i++)
       {
          graph.clearGraphRandom();
          graph.generateRandom(30,30);
          this.updateResults(graph);
       }
       this.clearResults();
       graph.copyGraph(g);
    }
    
    public void updateResults(Graph graph)
    {       
        objFunCost.calculateSolutionVector(graph);
        objFunCost.ComputeCost();
        if (running == true)
           numEvaluatedSolutions++;
        DecimalFormat df = new DecimalFormat("#.####");
        df.setRoundingMode(RoundingMode.CEILING);
        DrawingStage.rightbar.cont4NodeOcclusionResult.setText(""+df.format(objFunCost.normalizedVector.get(0).doubleValue()));
        DrawingStage.rightbar.cont4EdgeLengthResult.setText(""+df.format(objFunCost.normalizedVector.get(1).doubleValue()));
        DrawingStage.rightbar.cont4EdgeCrossingsResult.setText(""+df.format(objFunCost.normalizedVector.get(2).doubleValue()));
        DrawingStage.rightbar.cont4NodeEdgeOcclusionResult.setText(""+df.format(objFunCost.normalizedVector.get(3).doubleValue()));
        DrawingStage.rightbar.cont4AngularResolutionResult.setText(""+df.format(objFunCost.normalizedVector.get(4).doubleValue()));
        DrawingStage.rightbar.cont4ScreenCenterResult.setText(""+df.format(objFunCost.normalizedVector.get(5).doubleValue()));
        DrawingStage.rightbar.cont4ObjectiveFunctionResult.setText(""+df.format(objFunCost.cost)); 
        DrawingStage.rightbar.cont4EvaluatedSolutionsResult.setText(""+numEvaluatedSolutions);
        DrawingStage.rightbar.cont4ExecutionTimeResult.setText(""+df.format(executionTime / 1000000000.0));
        if (running)
            DrawingStage.rightbar.cont4DrawerStatus.setText("Processing");
        else 
            DrawingStage.rightbar.cont4DrawerStatus.setText("Idle");
    }
    
    public void updateResults(Graph graph, int v)
    {
        objFunCost.calculateSolutionVector(graph, v);
        objFunCost.ComputeCost();
        if (running == true)
           numEvaluatedSolutions++;
        DecimalFormat df = new DecimalFormat("#.####");
        df.setRoundingMode(RoundingMode.CEILING);
        DrawingStage.rightbar.cont4NodeOcclusionResult.setText(""+df.format(objFunCost.normalizedVector.get(0).doubleValue()));
        DrawingStage.rightbar.cont4EdgeLengthResult.setText(""+df.format(objFunCost.normalizedVector.get(1).doubleValue()));
        DrawingStage.rightbar.cont4EdgeCrossingsResult.setText(""+df.format(objFunCost.normalizedVector.get(2).doubleValue()));
        DrawingStage.rightbar.cont4NodeEdgeOcclusionResult.setText(""+df.format(objFunCost.normalizedVector.get(3).doubleValue()));
        DrawingStage.rightbar.cont4AngularResolutionResult.setText(""+df.format(objFunCost.normalizedVector.get(4).doubleValue()));
        DrawingStage.rightbar.cont4ScreenCenterResult.setText(""+df.format(objFunCost.normalizedVector.get(5).doubleValue()));
        DrawingStage.rightbar.cont4ObjectiveFunctionResult.setText(""+df.format(objFunCost.cost)); 
        DrawingStage.rightbar.cont4EvaluatedSolutionsResult.setText(""+numEvaluatedSolutions);
        DrawingStage.rightbar.cont4ExecutionTimeResult.setText(""+df.format(executionTime / 1000000000.0));
        if (running)
            DrawingStage.rightbar.cont4DrawerStatus.setText("Processing");
        else 
            DrawingStage.rightbar.cont4DrawerStatus.setText("Idle");
    }
    
    public void clearResults()
    {
        numEvaluatedSolutions=0; 
        executionTime = 0; 
        DrawingStage.rightbar.cont4NodeOcclusionResult.setText("0.0");
        DrawingStage.rightbar.cont4EdgeLengthResult.setText("0.0");
        DrawingStage.rightbar.cont4EdgeCrossingsResult.setText("0.0");
        DrawingStage.rightbar.cont4NodeEdgeOcclusionResult.setText("0.0");
        DrawingStage.rightbar.cont4AngularResolutionResult.setText("0.0");
        DrawingStage.rightbar.cont4ScreenCenterResult.setText("0.0");
        DrawingStage.rightbar.cont4ObjectiveFunctionResult.setText("0.0"); 
        DrawingStage.rightbar.cont4EvaluatedSolutionsResult.setText("0");
        DrawingStage.rightbar.cont4ExecutionTimeResult.setText("0");
        DrawingStage.rightbar.cont4DrawerStatus.setText("Idle");
    }
    
    public void clearPartialResults()
    {
        numEvaluatedSolutions=0; 
        DrawingStage.rightbar.cont4EvaluatedSolutionsResult.setText("0");
        DrawingStage.rightbar.cont4ExecutionTimeResult.setText("0");
        DrawingStage.rightbar.cont4DrawerStatus.setText("Idle");
    }
    
    // this is used in the TopRunBatchStage class for clearing the data of the drawer after each run 
    public void clearDrawerData(Graph graph, int phase, Drawer d)
    {
        objFunCost = new ObjectiveFunction(graph); 
        objFunCost.copyHistory(d.objFunCost);
        numEvaluatedSolutions = 0; 
        executionTime = 0; 
        running = false; 
        phaseNumber = phase; 
    }    
}
